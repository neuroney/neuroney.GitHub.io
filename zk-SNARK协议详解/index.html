<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"neuroney.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://neuroney.github.io/zk-SNARK%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://neuroney.github.io/zk-SNARK%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","path":"zk-SNARK协议详解/","title":"zk-SNARK 协议详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>zk-SNARK 协议详解 | Neptune</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Neptune</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li><li class="menu-item menu-item-colophon"><a href="/colophon/" rel="section">Colophon</a></li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://neuroney.github.io/zk-SNARK%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jinyuan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neptune">
      <meta itemprop="description" content="Document my life.">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="zk-SNARK 协议详解 | Neptune">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          zk-SNARK 协议详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-03 20:26:53" itemprop="dateCreated datePublished" datetime="2022-07-03T20:26:53+08:00">2022-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-06 17:08:04" itemprop="dateModified" datetime="2022-07-06T17:08:04+08:00">2022-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cryptography/" itemprop="url" rel="index"><span itemprop="name">Cryptography</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇文章是学习 zk-SNARK 协议时，所做的一些记录。</p>
<span id="more"></span>
<h2 id="zk-snark">zk-SNARK</h2>
<p>Zero-Knowledge Succinct Non-interactive Argument of
Knowledge（zk-SNARK）是零知识证明系统的一个实用的密码学实现。</p>
<ul>
<li>Zero-knowledge：零知识性，除了所做的陈述（statement）的真实性外，不透露任何其他与陈述有关的信息。</li>
<li>Succinct：简洁性，证明（proof）应当是简短的，易存储的，容易验证的。</li>
<li>Non-interactive：非交互性，在构建和存储证明的过程中，不需要类似挑战/问答的轮询。即该证明可以被计算和公开验证。</li>
<li>Argument of Knowledge：Argument
指的是对给定陈述，我们可以给出证明，该证明需要满足完备性（Completeness），即为真的陈述有证明，为假的陈述没有证明。Knowledge
指的是证明这在对陈述制造一个可信的证明时，必须知道一个证据（witness），witness
在密码学中指的是可以验证给定陈述为真的证据。那么，在这里，argument of
knowledge 指的是一种可以对指定证据制造可信证明的能力</li>
</ul>
<p>注：在密码学专用名词中，argument 和 proof 是相对的概念，一般 argument
指的是计算安全的（computationally
sound），即假定敌手的算力是多项式有限的；而 proof
则是统计安全的（statistical
sound），在假定敌手是算力无限的情况下的安全。</p>
<p>从实用的角度上，一个 zk-SNARK
提供了一种对给定计算验证正确性，却不泄露所使用的值的证明方式。这里，给定的计算一般指
NP 问题。</p>
<h2 id="polynomial">Polynomial</h2>
<p>多项式是 zk-SNARK 构造的核心。</p>
<p>由算数基本定理（Fundamental Theorem of
Algebra）保证，一个次数（degree）为 <span
class="math inline">\(d\)</span> 的多项式，最多有 <span
class="math inline">\(d\)</span>
个零点。亦即两个不同的多项式（次数相同）最多有 <span
class="math inline">\(d\)</span> 个交点。</p>
<p>如果一个证明者声称他知道某个次数为 <span
class="math inline">\(d\)</span>
的多项式，我们可以通过评估（evaluate）这个多项式在特定点的值来验证这个声明是否正确，考虑点的范围是
1 到 <span
class="math inline">\(10^{77}\)</span>，在特定点，其评估相同的概率最多为
<span
class="math inline">\(\frac{d}{10^{77}}\)</span>，是可忽略的（negligible）。因此我们可以构建一个简单的协议
1 来验证这个声明：</p>
<ul>
<li>验证者（Verifier）随机选取 <span
class="math inline">\(x\)</span>，并在本地评估多项式 <span
class="math inline">\(P&#39;\)</span> 在 <span
class="math inline">\(x\)</span> 点的值 <span
class="math inline">\(P&#39;(x)\)</span></li>
<li>验证者将 <span class="math inline">\(x\)</span>
发送给证明者（Prover），并要求其返回其所声称的多项式在 <span
class="math inline">\(x\)</span> 上的评估</li>
<li>证明者计算 <span class="math inline">\(x\)</span> 在其所生成的多项式
<span class="math inline">\(P\)</span> 上的值，<span
class="math inline">\(P(x)\)</span> 并发送给验证者</li>
<li>验证者检查 <span class="math inline">\(P&#39;(x)\)</span> 与 <span
class="math inline">\(P(x)\)</span>
是否相等，如果相等，那么证明者的陈述可以以一个极高的概率所证明。</li>
</ul>
<p>但在这个协议中，多项式 <span class="math inline">\(P\)</span>
的信息完全地公开了。我们不希望公开多项式的信息。考虑这样的场景，证明者声称自己知道一个次数为
3，有两个根分别为 1 和 2 的多项式 <span
class="math inline">\(P\)</span>。</p>
<p>不妨 <span
class="math inline">\(t(x)=(x-1)(x-2)\)</span>，即后文中的目标多项式（target
polynomial）。由算数基本定保证，<span
class="math inline">\(P(x)=H(x)\cdot
t(x)\)</span>，即这里必然存在这样的多项式 <span
class="math inline">\(H(x)\)</span> 满足这个等式。也就是说，<span
class="math inline">\(P(x)\)</span> 包含 <span
class="math inline">\(t(x)\)</span>，<span
class="math inline">\(P(x)\)</span> 有 <span
class="math inline">\(t(x)\)</span> 的全部零点。在不公开 <span
class="math inline">\(P(x)\)</span>，仅陈述 <span
class="math inline">\(t(x)\)</span>
的条件下，一个很自然的证明方法就是找到 <span
class="math inline">\(H(x)=\frac{P(x)}{t(x)}\)</span>，其中除法没有余数，<span
class="math inline">\(H(x)\)</span> 是一个整多项式。</p>
<p>那么我们可以更新协议 1 为协议 2:</p>
<ul>
<li>验证者（Verifier）随机选取数 <span
class="math inline">\(r\)</span>，并计算（评估） <span
class="math inline">\(t=t(r)\)</span>，并将 <span
class="math inline">\(r\)</span> 发送给证明者</li>
<li>证明者计算 <span
class="math inline">\(H(x)=\frac{P(x)}{t(x)}\)</span> 并计算 <span
class="math inline">\(h=H(r)\)</span> 和 <span
class="math inline">\(p=P(r)\)</span>，将 <span
class="math inline">\(h\)</span> 和 <span
class="math inline">\(p\)</span> 发送给验证者</li>
<li>验证者检查 <span class="math inline">\(h\cdot t\)</span> 与 <span
class="math inline">\(p\)</span> 是否相等，如果想等，那么 <span
class="math inline">\(P(x)\)</span> 确实包含 <span
class="math inline">\(t(x)\)</span>。</li>
</ul>
<p>协议 2
可以在不泄漏多项式本身的情况下，完成对拥有某些性质的多项式的检查。但仍存在以下的问题：</p>
<ul>
<li>证明者可以只发送使得 <span class="math inline">\(h\cdot t=p\)</span>
等式成立的 <span class="math inline">\(h\)</span> 和 <span
class="math inline">\(t\)</span> 使得验证通过，而不需要真的知道多项式
<span class="math inline">\(P\)</span>。</li>
<li>因为证明者知道随机的点 <span
class="math inline">\(r\)</span>，证明者可以构造任意的多项式 <span
class="math inline">\(P&#39;\)</span>，使得 <span
class="math inline">\(P&#39;(r)=t(r)\cdot H(r)\)</span>。</li>
<li>证明者可以通过构造更高次数的多项式来作弊。</li>
</ul>
<h2 id="homomorphic-encryption">Homomorphic Encryption</h2>
<p>从上一节中，<span class="math inline">\(r\)</span>
是明文传输的，这样证明者就可以根据 <span
class="math inline">\(r\)</span> 来作弊。Homomorphic
encryption（HE）可以将 <span class="math inline">\(r\)</span>
加密后传输，但不影响对 <span class="math inline">\(r\)</span>
进行相关的线性（加法、乘法）运算。一个比较经典的 HE
构造方法，就是在有限域内的指数运算，其逆运算是困难的，由 Diffie-Hellman
假设来保证。即加密方法为：<span
class="math inline">\(E(v)=g^v\pmod{n}\)</span>，<span
class="math inline">\(v\)</span>
就是我们想要加密的变量。它可以支持加密后的变量做加法和乘法运算：</p>
<ul>
<li>乘法：<span
class="math inline">\((g^i)^j=g^{ij}\pmod{n}\)</span></li>
<li>加法：<span class="math inline">\(g^i\cdot
g^j=g^{i+j}\pmod{n}\)</span></li>
</ul>
<p>同样地，对于一个多项式 <span
class="math inline">\(P(x)=x^3-3x^2+2x\)</span>。我们可以知道：</p>
<p><span
class="math display">\[\begin{aligned}E(P(x))&amp;=g^{x^3-3x^2+2x}\\
&amp;=g^{x^3}\cdot g^{-3x^2} \cdot g^{2x}\\
&amp;=(g^{x^3})^1\cdot (g^{x^2})^{-3} \cdot (g^{x})^2\\
&amp;=(E(x^3))^1\cdot (E(x^2))^{-3}\cdot
(E(x))^2\end{aligned}\]</span></p>
<p>因此我们只要知道 <span
class="math inline">\(E(x),E(x^2),E(x^3)\)</span>
的值，就可以计算出加密后的多项式在 <span
class="math inline">\(x\)</span> 点的取值。对于一个次数为 <span
class="math inline">\(d\)</span> 的多项式，我们可以更新协议 2 为协议
3：</p>
<ol type="1">
<li>验证者
<ul>
<li>选取生成元 <span class="math inline">\(g\)</span></li>
<li>选取随机数 <span class="math inline">\(s\)</span></li>
<li>计算 <span class="math inline">\(s^i,i\in[0,d]\)</span>
的同态加密值，<span class="math inline">\(E(s^i)=g^{s^i}\)</span></li>
<li>直接计算目标多项式 <span class="math inline">\(t(x)\)</span> 在
<span class="math inline">\(s\)</span> 点的取值，<span
class="math inline">\(t(s)\)</span></li>
<li>向证明者发送 <span
class="math inline">\(E(s^0),E(s^1),\cdots,E(s^d)\)</span></li>
</ul></li>
<li>证明者
<ul>
<li>计算多项式 <span
class="math inline">\(H(x)=\frac{P(x)}{t(x)}\)</span></li>
<li>使用接收到的加密值集合，和已知的 <span
class="math inline">\(P(x)\)</span> 的系数集合 <span
class="math inline">\(c_0,\cdots,c_d\)</span>，计算 <span
class="math inline">\(g^p=E(P(s))=g^{P(s)}=g^{c_0s^0+c_1s^1+\cdots+c_ds^d}=\prod_{i=0}^d(E(s^i))^{c_i}\)</span></li>
<li>计算 <span class="math inline">\(g^h=E(H(s))=g^{H(s)}\)</span></li>
<li>将 <span class="math inline">\(g^p\)</span> 和 <span
class="math inline">\(g^h\)</span> 发送给验证者</li>
</ul></li>
<li>验证者
<ul>
<li>检查 <span class="math inline">\(g^p\)</span> 是否等于 <span
class="math inline">\((g^h)^{t(s)}\)</span></li>
</ul></li>
</ol>
<h2 id="knowledge-of-exponent-assumption">Knowledge of Exponent
Assumption</h2>
<p>在协议 3 中，证明者不知道 <span class="math inline">\(s\)</span>
的取值，因此其构造不合法的 <span class="math inline">\(P\)</span>
的难度增加了，但证明者依旧可以找到某些 <span
class="math inline">\(z_p\)</span> 和 <span
class="math inline">\(z_h\)</span> 使得 <span
class="math inline">\(z_p=(z_h)^{t(s)}\)</span>，从而代替原本要发送的
<span class="math inline">\(g^p\)</span> 和 <span
class="math inline">\(g^h\)</span>。例如，对某个随机数 <span
class="math inline">\(r\)</span>，证明者可选取 <span
class="math inline">\(z_h=g^r, z_p=(g^{t(s)})^r\)</span>，<span
class="math inline">\(g^{t(s)}\)</span> 可以通过 <span
class="math inline">\(t(x)\)</span> 和加密后的 <span
class="math inline">\(s\)</span> 指数幂集合算出。因此验证者需要验证
<span class="math inline">\(g^p\)</span> 和 <span
class="math inline">\(g^h\)</span> 是只使用给定的加密后的 <span
class="math inline">\(s\)</span>
指数幂集合算出，而非证明者随机生成的值。</p>
<p>只用给定的加密后的<span class="math inline">\(s\)</span> 指数幂集合
<span class="math inline">\(g^{s^0},\cdots,g^{s^d}\)</span>
进行，其结果必然是 <span class="math inline">\((g^{s^i})^c\)</span>
的形式 ，对某些随机的 <span class="math inline">\(c\)</span>
值。一种检验方法，即是如果对 <span
class="math inline">\(g^{s^i}\)</span> 做了运算，则对一个 <span
class="math inline">\(g^{s^i}\)</span> 的偏移（shifted）集合 <span
class="math inline">\(g^{\alpha s^i}\)</span> 做同样的运算。</p>
<p>这就是 [Dam91] 所介绍的 Knowledge of Exponent
Assumption（KEA），其详细的过程是：</p>
<ul>
<li>Alice 拥有值 <span class="math inline">\(a\)</span>，她要求 Bob
返回一个 <span class="math inline">\(a\)</span>
的指数次幂，唯一要求是该返回值必须由 <span
class="math inline">\(a\)</span> 计算出，她所做的过程如下：
<ul>
<li>随机选取值 <span class="math inline">\(\alpha\)</span></li>
<li>计算 <span
class="math inline">\(a&#39;=a^{\alpha}\pmod{n}\)</span></li>
<li>将 <span class="math inline">\((a,a&#39;)\)</span> 发送给 Bob，要求
Bob 返回 <span class="math inline">\((b,b&#39;)\)</span>，<span
class="math inline">\(b&#39;\)</span> 和 <span
class="math inline">\(b\)</span> 仍然满足 <span
class="math inline">\(\alpha\)</span>-偏移的关系</li>
</ul></li>
<li>因为 Bob 除了暴力搜索的方法外无法从 <span
class="math inline">\((a,a&#39;)\)</span> 中获取 <span
class="math inline">\(\alpha\)</span>，所以 Bob 的构造只能用如下的方法：
<ul>
<li>随机选取值 <span class="math inline">\(c\)</span></li>
<li>计算 <span class="math inline">\(b=(a)^c\pmod{n}\)</span> 和 <span
class="math inline">\(b&#39;=(a&#39;)^c\pmod{n}\)</span></li>
<li>返回 <span class="math inline">\((b,b&#39;)\)</span></li>
</ul></li>
<li>Alice 检查 <span class="math inline">\(b^{\alpha}\)</span> 和 <span
class="math inline">\(b&#39;\)</span> 是否相等</li>
</ul>
<p>上述流程保证了 Bob 确实对给定的数值（i.e. <span
class="math inline">\(a,a&#39;\)</span>）使用了同样的指数运算（i.e.
<span class="math inline">\(c\)</span>）；以及 Bob 只能够使用 Alice
提供的数值去满足 <span class="math inline">\(\alpha\)</span>-偏移；以及
Bob 确实知道（know）他所应用的指数 <span
class="math inline">\(c\)</span>，因为 <span
class="math inline">\(b\)</span> 和 <span
class="math inline">\(b&#39;\)</span> 使用相同的指数 <span
class="math inline">\(c\)</span> 计算而来；以及 Alice 并不知道 <span
class="math inline">\(c\)</span> 且 Bob 不知道 <span
class="math inline">\(\alpha\)</span>。</p>
<p>将 KEA 添加到协议 3
中，可以限制（restrict）证明者只能使用验证者发送的 <span
class="math inline">\(g^{s^i}\)</span> 集合，因此，可以构造协议 4
如下：</p>
<ol type="1">
<li>验证者
<ul>
<li>选取生成元 <span class="math inline">\(g\)</span></li>
<li>随机选取 <span class="math inline">\(s,\alpha\)</span></li>
<li>计算 <span class="math inline">\(s^i,i\in[0,d]\)</span>
的同态加密值，<span class="math inline">\(E(s^i)=g^{s^i}\)</span></li>
<li>计算 <span class="math inline">\(s^i\)</span> 的 <span
class="math inline">\(\alpha\)</span>-偏移，即 <span
class="math inline">\(g^{\alpha s^i}\)</span></li>
<li>直接计算目标多项式 <span class="math inline">\(t(x)\)</span> 在
<span class="math inline">\(s\)</span> 点的取值，<span
class="math inline">\(t(s)\)</span></li>
<li>向证明者发送 <span
class="math inline">\(g^{s^0},g^{s^1},\cdots,g^{s^d},g^{\alpha
s^0},g^{\alpha s^1},\cdots,g^{\alpha s^d}\)</span></li>
</ul></li>
<li>证明者
<ul>
<li>计算多项式 <span
class="math inline">\(H(x)=\frac{P(x)}{t(x)}\)</span></li>
<li>使用接收到的加密值集合，和已知的 <span
class="math inline">\(P(x)\)</span> 的系数集合 <span
class="math inline">\(c_0,\cdots,c_d\)</span>，计算 <span
class="math inline">\(g^p=g^{P(s)}=g^{c_0s^0+c_1s^1+\cdots+c_ds^d}=\prod_{i=0}^d(g^{s^i})^{c_i}\)</span></li>
<li>使用接收到的加密值的偏移集合，和已知的 <span
class="math inline">\(P(x)\)</span> 的系数集合 <span
class="math inline">\(c_0,\cdots,c_d\)</span>，计算 <span
class="math inline">\(g^{p&#39;}=g^{\alpha P(s)}=g^{c_0\alpha
s^0+c_1\alpha s^1+\cdots+c_d\alpha s^d}=\prod_{i=0}^d(g^{\alpha
s^i})^{c_i}\)</span></li>
<li>计算 <span class="math inline">\(g^h=E(H(s))=g^{H(s)}\)</span></li>
<li>将 <span class="math inline">\(g^p,g^{p&#39;}\)</span> 和 <span
class="math inline">\(g^h\)</span> 发送给验证者</li>
</ul></li>
<li>验证者
<ul>
<li>检查 <span class="math inline">\(g^p\)</span> 是否等于 <span
class="math inline">\((g^h)^{t(s)}\)</span></li>
<li>检查 <span class="math inline">\(g^{p&#39;}\)</span> 是否等于 <span
class="math inline">\((g^p)^{\alpha}\)</span></li>
</ul></li>
</ol>
<h2 id="non-interactivity">Non-interactivity</h2>
<p>至此，我们已经构造出了一个交互式的协议，交互式意味着，证明只可以由最初的验证者来验证，而无法被别人所验证。这样的协议是无法被其他人所信任的，因为：</p>
<ul>
<li>验证者可以和证明者串通，共享随机数 <span
class="math inline">\(s,\alpha\)</span>，这样来制作一个假的证明</li>
<li>证明者自身可以同样构造一个假的证明</li>
<li>验证者需要存储 <span class="math inline">\(\alpha,t(s)\)</span>
直到证明结束，在这期间，有泄露参数的风险</li>
</ul>
<p>如果证明者只想是特定的验证者（designated
verifier）验证证明的过程，且证明过程无法被其他人所复用，那么交互式的协议是有效的。但如果证明者试图想多个验证者证明，那么与每个验证者都需要执行一次协议，这样的效率是不高的。因此，我们还需要其他工具来使得协议所需的参数是可重用的、公开的、可信赖的、不容易滥用的。</p>
<p>首先要做的就是对 <span class="math inline">\(\alpha,t(s)\)</span>
进行加密，我们同样可以使用前文提到的 HE 来对这两个进行加密。但是 HE
并不支持对两个加密后的变量做乘法运算，即 <span class="math inline">\((g
^p)^{\alpha}\)</span> 无法通过 <span class="math inline">\(g^p\)</span>
和 <span class="math inline">\(g^{\alpha}\)</span> 来计算。</p>
<p>在这里，要对两个加密后的值做乘法，需要引入一个新的密码学工具双线性映射（bilinear
map），表示为 <span
class="math inline">\(e(g^*,g^*)\)</span>。给定两个加密后的值 （i.e.
<span
class="math inline">\(g^a,g^b\)</span>），可以将其映射到它们乘积的结果（i.e.
<span class="math inline">\(e(g,g)^{ab}\)</span>）。</p>
<p>双线性映射的一个很重要的性质就是，它满足一种类似的指数幂的乘法性质：</p>
<p><span
class="math display">\[e(g^a,g^b)=e(g^b,g^a)=e(g^{ab},g^1)=\cdots=e(g^i,g^j)\quad
\mathrm{if}\quad ij=ab\]</span></p>
<p>以及一种类似的指数幂加法性质：</p>
<p><span class="math display">\[e(g^a,g^b)\cdot
e(g^c,g^d)=e(g,g)^{ab+cd}\]</span></p>
<p>有了双线性映射，我们就可以将协议 4
中的验证者之行的第一阶段改为由可信方生成随机数 <span
class="math inline">\(\alpha, s\)</span>，加密后公布 （<span
class="math inline">\(g^{t(s)},g^\alpha,g^{s},g^{\alpha{s^i}};i\in[0,d]\)</span>）并销毁随机数。通常我们把这一串数值叫做
commen reference string（CRS）。</p>
<p>现在我们可以构造协议 5 如下：</p>
<ul>
<li><p>设置（Setup）</p>
<ul>
<li><p>选取生成元 <span class="math inline">\(g\)</span> 和双线性映射
<span class="math inline">\(e\)</span></p></li>
<li><p>选取随机数 <span class="math inline">\(s,
\alpha\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^\alpha,
\{g^{s^i}\}_{i\in[d]},\{g^{\alpha s^i}\}_{i\in[0,d]}\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^{t(s)}\)</span></p></li>
<li><p>证明密钥（proving key）或评估密钥（evaluation key）：<span
class="math inline">\(\{g^{s^i}\}_{i\in[d]},\{g^{\alpha
s^i}\}_{i\in[0,d]}\)</span><br />
</p></li>
<li><p>验证密钥（verification key）：<span
class="math inline">\((g^{t(s)},g^\alpha)\)</span></p></li>
</ul></li>
<li><p>证明（Proving）</p>
<ul>
<li><p>已知多项式 <span class="math inline">\(P(x)\)</span> 的系数集合
<span class="math inline">\(\{c_i\}_{i\in[0,d]}\)</span>，<span
class="math inline">\(P(x)=\sum_{i=0}^d c_ix^i\)</span></p></li>
<li><p>计算多项式 <span
class="math inline">\(H(x)=\frac{P(x)}{t(x)}\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{s^i}\}_{i\in[d]}\)</span>
计算 <span class="math inline">\(g^{P(s)}\)</span> 和 <span
class="math inline">\(g^{H(s)}\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{\alpha
s^i}\}_{i\in[d]}\)</span> 计算 <span class="math inline">\(g^{\alpha
P(s)}\)</span></p></li>
<li><p>生成证明 <span
class="math inline">\(\pi=(g^{P(s)},g^{H(s)},g^{\alpha
P(s)})\)</span></p></li>
</ul></li>
<li><p>验证（Verification）</p>
<ul>
<li>收取到证明 <span
class="math inline">\(\pi=(g^p,g^h,g^{p&#39;})\)</span></li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算，<span
class="math inline">\(e(g^{p&#39;},g)=e(g^p,g^\alpha)\)</span></li>
<li>检查多项式系数，即证明者是否知道 <span
class="math inline">\(P(x)\)</span>，亦即 <span
class="math inline">\(p\)</span> 和 <span
class="math inline">\(t(s)\cdot h\)</span> 的关系,<span
class="math inline">\(e(g^p,g)=e(g^{t(s)},g^h)\)</span></li>
</ul></li>
</ul>
<p>注：如果双线性映射的结果是可以重用的，那么这个协议也是不安全的，因为证明者可以使用
<span class="math inline">\(g^{p&#39;}=e(g^p,g^\alpha)\)</span>
来通过多项式限制检查：</p>
<p><span
class="math display">\[e(e(g^{p},g^{\alpha}),g)=e(g^p,g^{\alpha})\]</span></p>
<h3 id="multi-party-commen-reference-string-optional">Multi-party Commen
Reference String (optional)</h3>
<p>但上文的 CRS
是由唯一的可信方生成的，为了达到不依赖于特定的第三方的目的，我们可以使用如下的方法来生成
CRS，假设有三个参与方 A，B，C 参与协议的构建：</p>
<ul>
<li>A 随机选取 <span
class="math inline">\(s_A,\alpha_A\)</span>，并公布她的 CRS： <span
class="math display">\[(g^{s^i_A},g^{\alpha_A},g^{\alpha_A
s^i_A})\]</span></li>
<li>B 随机选取 <span class="math inline">\(s_B,\alpha_B\)</span>，通过对
A 的 CRS 计算自己的 CRS： <span
class="math display">\[((g^{s^i_A})^{s^i_B},(g^{\alpha_A})^{\alpha_B},(g^{\alpha_A
s^i_A})^{\alpha_B s^i_B})=(g^{(s_As_B)^i},g^{\alpha_A
\alpha_B},g^{\alpha_A \alpha_B (s_As_B)^i})\]</span> 并公布计算结果 AB
的 CRS： <span
class="math display">\[(g^{s^i_{AB}},g^{\alpha_{AB}},g^{\alpha_{AB}
s^i_{AB}})\]</span></li>
<li>C 随机选取 <span class="math inline">\(s_C,\alpha_C\)</span>，通过对
AB 的 CRS 计算自己的 CRS： <span
class="math display">\[((g^{s^i_{AB}})^{s^i_C},(g^{\alpha_{AB}})^{\alpha_C},(g^{\alpha_{AB}
s^i_{AB}})^{\alpha_C s^i_C})=(g^{(s_As_Bs_C)^i},g^{\alpha_A \alpha_B
\alpha_C},g^{\alpha_A \alpha_B \alpha_C (s_As_Bs_C)^i})\]</span>
并公布计算结果 ABC 的 CRS： <span
class="math display">\[(g^{s^i_{ABC}},g^{\alpha_{ABC}},g^{\alpha_{ABC}
s^i_{ABC}})\]</span></li>
</ul>
<p>最后 <span
class="math inline">\((g^{s^i_{ABC}},g^{\alpha_{ABC}},g^{\alpha_{ABC}
s^i_{ABC}})\)</span> 就可以作为三方共同的
CRS，并且三方各自都不知道随机参数 <span class="math inline">\(s^i=s^i_A
s^i_B s^i_C\)</span> 和 <span class="math inline">\(\alpha=\alpha_A
\alpha_B \alpha_C\)</span> 的值。但 A，B，C
其中的某一方可以使用任意的值来代替本该要计算的值来作弊，为了检验 CRS
的参与方每一方都使用了规定的数值计算（B 使用 A 的 CRS 计算 AB，C 使用 AB
的 CRS 来计算 ABC）我们可以将双线性映射用来检查 B 和 C
是否使用了正确的参数，比如 Bob 可以公开她加密后的参数：</p>
<p><span class="math display">\[(g^{s^i_B},g^{\alpha_B},g^{\alpha_B
s^i_B})|_{i\in[d]}\quad \mathrm{where}\quad
[d]=\{1,\cdots,d\}\]</span></p>
<p>这样就可以验证 Bob 公布的 CRS 是否是由 A 的 CRS 计算而来，对 <span
class="math inline">\(i\in[0,d]\)</span> 检查：</p>
<ul>
<li><span
class="math inline">\(e(g^{s^i_{AB}},g)=e(g^{s^i_A},g^{s^i_B})\)</span></li>
<li><span
class="math inline">\(e(g^{\alpha_{AB}},g)=e(g^{\alpha_A},g^{\alpha_B})\)</span></li>
<li><span class="math inline">\((g^{\alpha_{AB}
s^i_{AB}},g)=e(g^{\alpha_A s^i_A},g^{\alpha_B s^i_B})\)</span></li>
</ul>
<p>同样地，C 也需要证明她的 CRS 是使用 AB 的 CRS 得到的。</p>
<h2 id="quadratic-arithmetic-program">Quadratic Arithmetic Program</h2>
<p>关于 QAP 的详细内容，见<a
target="_blank" rel="noopener" href="https://www.neoyuan.xyz/QAP%E8%AF%A6%E8%A7%A3/">上篇博客</a>。QAP
最终将我们想要验证的计算问题转化为了多项式的整除性检查。</p>
<p>现在应用 QAP 到协议 4 上，即证明者声称其计算的 <span
class="math inline">\(F\)</span> 函数结果是正确的。那么他需要将 <span
class="math inline">\(F\)</span> 转化为 QAP <span
class="math inline">\(Q\)</span>，包括一个目标多项式 <span
class="math inline">\(t(x)\)</span> 和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>。（在本文中设 <span
class="math inline">\(v_0(x)=w_0(x)=y_0(x)=0\)</span>，可以不做考虑）我们可以构造协议
6 如下：</p>
<ul>
<li><p>设置（Settup）</p>
<ul>
<li><p>选取生成元 <span class="math inline">\(g\)</span> 和双线性映射
<span class="math inline">\(e\)</span></p></li>
<li><p>选取随机数 <span class="math inline">\(s,
\alpha_v,\alpha_w,\alpha_y\)</span></p></li>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>计算 <span
class="math inline">\(\{g^{s^i}\}_{i\in[d]},\{g^{v_i(s)},g^{w_i(s)},g^{
y_i(s)}\}_{i\in[d]},\{g^{\alpha_v v_i(s)},g^{\alpha_w
w_i(s)},g^{\alpha_y y_i(s)}\}_{i\in[d]}\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^t=g^{t(s)}\)</span></p></li>
<li><p>证明密钥：<span
class="math inline">\((\{g^{s^i}\}_{i\in[d]},\{g^{v_i(s)},g^{w_i(s)},g^{
y_i(s)},g^{\alpha_v v_i(s)},g^{\alpha_w w_i(s)},g^{\alpha_y
y_i(s)}\}_{i\in[m]})\)</span></p></li>
<li><p>验证密钥：<span
class="math inline">\((g^1,g^{\alpha_v},g^{\alpha_w},g^{\alpha_y},g^{t})\)</span></p></li>
</ul></li>
<li><p>证明（Proving）</p>
<ul>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>根据输入 <span class="math inline">\(u\)</span>，计算 <span
class="math inline">\(F(u)\)</span>，以及满足 QAP 的合法赋值 <span
class="math inline">\(\{c_i\}_{i\in[m]}\)</span></p></li>
<li><p>计算多项式 <span class="math display">\[V(x)=\sum_{i=1}^mc_i\cdot
v_i(x),W(x)=\sum_{i=1}^mc_i\cdot w_i(x),Y(x)=\sum_{i=1}^mc_i\cdot
y_i(x)\]</span></p></li>
<li><p>计算多项式 <span class="math inline">\(H(x)=\frac{V(x)\cdot
W(x)-Y(x)}{t(x)}\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{s^i}\}_{i\in[d]}\)</span>
计算 <span class="math inline">\(g^{H(s)}\)</span></p></li>
<li><p>计算操作数多项式（operand polynomials） <span
class="math display">\[g^{V(s)}=\prod_{i=1}^m(g^{v_i(s)})^{c_i},g^{W(s)}=\prod_{i=1}^m(g^{w_i(s)})^{c_i},,g^{Y(s)}=\prod_{i=1}^m(g^{y_i(s)})^{c_i}\]</span></p></li>
<li><p>计算偏移多项式 <span class="math display">\[g^{\alpha_v
V(s)}=\prod_{i=1}^m(g^{\alpha_v v_i(s)})^{c_i},g^{\alpha_w
W(s)}=\prod_{i=1}^m(g^{\alpha_w w_i(s)})^{c_i},,g^{\alpha_y
Y(s)}=\prod_{i=1}^m(g^{\alpha_y y_i(s)})^{c_i}\]</span></p></li>
<li><p>生成证明 <span
class="math inline">\(\pi_F=(g^{V(s)},g^{W(s)},g^{Y(s)},g^{\alpha
V(s)},g^{\alpha W(s)},g^{\alpha Y(s)},g^{H(s)} )\)</span></p></li>
</ul></li>
<li><p>验证（Verification）</p>
<ul>
<li>收取到证明 <span class="math inline">\(\pi=(g^{V},g^{W},g^{Y},g^{
V&#39;},g^{W&#39;},g^{Y&#39;},g^{H} )\)</span></li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算，<span
class="math inline">\(e(g^{V&#39;},g)=e(g^V,g^{\alpha_v}),e(g^{W&#39;},g)=e(g^W,g^{\alpha_w}),e(g^{Y&#39;},g)=e(g^Y,g^{\alpha_y})\)</span></li>
<li>检查多项式系数，即证明者是否使用了正确的系数来计算 <span
class="math inline">\(F(u)\)</span>，亦即 <span
class="math inline">\(V\cdot W-Y\)</span> 和 <span
class="math inline">\(t\cdot h\)</span> 的关系，<span
class="math inline">\(e(g^V,g^W)=e(g^{t},g^h)\cdot
e(g^Y,g)\)</span></li>
</ul></li>
</ul>
<p>注：如果使用同一个 <span class="math inline">\(\alpha\)</span> 来代替
<span
class="math inline">\(\alpha_v,\alpha_w,\alpha_y\)</span>，则无法保证证明者正确地构造了
<span
class="math inline">\(V,W,Y\)</span>，如证明者可以重用操作多项式，交换操作多项式的顺序，使用其他的操作数来伪造
<span class="math inline">\(\alpha\)</span>-偏移。</p>
<h2 id="variable-consistency-across-operands">Variable Consistency
Across Operands</h2>
<p>对任意一个变量 <span
class="math inline">\(c_i\)</span>，它需要被计算到一个变量多项式（variable
polynomial）中，即 <span
class="math inline">\((g^{v_i(s)})^{c_i},(g^{w_i(s)})^{c_i},(g^{y_i(s)})^{c_i}\)</span>。因为对操作多项式使用的检验是分别进行的（三个
<span
class="math inline">\(\alpha\)</span>-偏移检验），但并没有保证每一个变量
<span class="math inline">\(c_i\)</span>
都被使用到了相对应的变量多项式上，所以我们可以添加一个 <span
class="math inline">\(\beta\)</span>-偏移来对每一个变量 <span
class="math inline">\(c_i\)</span> 所对应的变量多项式同时检验，例如计算
<span class="math inline">\(g^{v_i(s)+w_i(s)+y_i(s)}\)</span> 及其偏移
<span class="math inline">\(g^{\beta (v_i(s)+w_i(s)+y_i(s))}\)</span>
。那么要对 <span class="math inline">\(c_i\)</span>
及其对应多项式的检验可以写为如下形式：<span
class="math display">\[(g^{V_i(s)})^{c_{V,i}},(g^{W_i(s)})^{c_{W,i}},(g^{Y_i(s)})^{c_{Y,i}},(g^{\beta(V_i(s)+W_i(s)+Y_i(s))})^{c_{\beta,i}}\]</span></p>
<p>如果每一个变量多项式都使用了正确的变量 <span
class="math inline">\(c_i\)</span>，即 <span
class="math inline">\(c_{V,i}=c_{W,i}=c_{Y,i}=c_{\beta,i},i\in[m]\)</span>，那么：<span
class="math display">\[e(g^{c_{V,i}\cdot V_i(s)}\cdot g^{c_{W,i}\cdot
W_i(s)}\cdot g^{c_{Y,i}\cdot Y_i(s)},g^{\beta})=e(g^{c_{\beta,i}\cdot
\beta(V_i(s)+W_i(s)+Y_i(s))},g)\]</span></p>
<p>但这样的检验并不安全，取 <span
class="math inline">\(V_i(x)=W_i(x),c_{\beta,i}=c_{Y,i},c_{V,i}=2c_{Y,i}-c_{W,i}\)</span>，即可通过验证。针对这个问题，用
<span class="math inline">\(\beta_v,\beta_w,\beta_y\)</span> 来代替
<span class="math inline">\(\beta\)</span>。我们可以对协议 6
添加如下部分（协议 7a）：</p>
<ul>
<li>设置
<ul>
<li>……</li>
<li>随机选取 <span
class="math inline">\(\beta_v,\beta_w,\beta_y\)</span></li>
<li>计算变量一致性多项式（variable consistency polynomial）<span
class="math inline">\(\{g^{\beta_v v_i(s)+\beta_w w_i(s)+\beta_y
y_i(s)}\}_{i\in[m]}\)</span> 并添加到证明密钥中</li>
<li>将 <span
class="math inline">\((g^{\beta_v},g^{\beta_w},g^{\beta_y})\)</span>
添加到验证密钥中</li>
</ul></li>
<li>证明
<ul>
<li>……</li>
<li>将赋值变量分配给对应的变量一致性多项式：<span
class="math inline">\(\{g^{z_i(s)}\}_{i\in [m]}=\{(g^{\beta_v
v_i(s)+\beta_w w_i(s)+\beta_y y_i(s)})^{c_i}\}_{i\in[m]}\)</span></li>
<li>计算 <span class="math inline">\(g^{Z(s)}=\prod_{i=1}^m
g^{z_i(s)}=g^{\beta_v V(s)+\beta_w W_i(s)+\beta_y Y_i(s)}\)</span>
并添加到证明 <span class="math inline">\(\pi_F\)</span> 中</li>
</ul></li>
<li>验证
<ul>
<li>……</li>
<li>检查操作多项式的一致性：<span
class="math display">\[e(g^V,g^{\beta_v})\cdot e(g^W,g^{\beta_w})
e(g^Y,g^{\beta_y}) = e(g^Z,g) \Leftrightarrow
e(g,g)^{\beta_vV+\beta_wW+\beta_yY}=e(g,g)^Z\]</span></li>
</ul></li>
</ul>
<p>但因为证明者可以知道 <span
class="math inline">\(g^{\alpha_v}\)</span> 和 <span
class="math inline">\(g^{\beta_v}\)</span>，他依然可以构造假的 <span
class="math inline">\(\mathcal{V,W,Y}\)</span> 来通过 <span
class="math inline">\(\alpha\)</span>-偏移检验和一致性检验。这里需要引入一个随机变量
<span class="math inline">\(\gamma\)</span> 来使得用 <span
class="math inline">\(g^{\beta_v},g^{\beta_w},g^{\beta_y}\)</span>
直接计算 <span class="math inline">\(g^{Z(s)}\)</span> 是冲突的，即用
<span class="math inline">\(g^{\beta_v \gamma},g^{\beta_w
\gamma},g^{\beta_y \gamma}\)</span> 来代替。即构造如下的协议 7b：</p>
<ul>
<li>设置
<ul>
<li>……</li>
<li>随机选取 <span
class="math inline">\(\beta_v,\beta_w,\beta_y,\gamma\)</span></li>
<li>计算变量一致性多项式（variable consistency polynomial）<span
class="math inline">\(\{g^{\beta_v v_i(s)+\beta_w w_i(s)+\beta_y
y_i(s)}\}_{i\in[m]}\)</span> 并添加到证明密钥中</li>
<li>将 <span
class="math inline">\((g^{\beta_v\gamma},g^{\beta_w\gamma},g^{\beta_y\gamma},g^{\gamma})\)</span>
添加到验证密钥中</li>
</ul></li>
<li>证明
<ul>
<li>……</li>
<li>将赋值变量分配给对应的变量一致性多项式：<span
class="math inline">\(\{g^{z_i(s)}\}_{i\in [m]}=\{(g^{\beta_v
v_i(s)+\beta_w w_i(s)+\beta_y y_i(s)})^{c_i}\}_{i\in[m]}\)</span></li>
<li>计算 <span class="math inline">\(g^{Z(s)}=\prod_{i=1}^m
g^{z_i(s)}=g^{\beta_v V(s)+\beta_w W_i(s)+\beta_y Y_i(s)}\)</span>
并添加到证明 <span class="math inline">\(\pi_F\)</span> 中</li>
</ul></li>
<li>验证
<ul>
<li>……</li>
<li>检查操作多项式的一致性：<span
class="math display">\[e(g^V,g^{\beta_v\gamma})\cdot
e(g^W,g^{\beta_w\gamma}) e(g^Y,g^{\beta_y\gamma}) =
e(g^Z,g^{\gamma})\]</span></li>
</ul></li>
</ul>
<p>但协议 8a 为验证密钥添加了 4 个元素，[Par+13]
则通过选取不同生成元的方式来减少了验证密钥数量，并增强了变量多项式的安全性，构造如下的协议
7c：</p>
<ul>
<li>设置
<ul>
<li>……</li>
<li>随机选取 <span
class="math inline">\(r_v,r_w,\beta,\gamma\)</span>，</li>
<li>计算 <span class="math inline">\(r_y=r_v\cdot r_w\)</span>
和操作多项式生成元（operand generator）<span
class="math inline">\(g_v=g^{r_v},g_w=g^{r_w},g_y=g^{r_y}\)</span><br />
</li>
<li>证明密钥：<span
class="math inline">\((\{g^{s^i}\}_{i\in[d]},\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)},g_v^{\alpha_v v_i(s)},g_w^{\alpha_w w_i(s)},g_y^{\alpha_y
y_i(s)},g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)}\}_{i\in[m]})\)</span></li>
<li>验证密钥：<span
class="math inline">\((g^1,g^{\alpha_v},g^{\alpha_w},g^{\alpha_y},g_y^{t},g^{\beta
\gamma},g^\gamma)\)</span></li>
</ul></li>
<li>证明
<ul>
<li>……</li>
<li>计算 <span class="math inline">\(g^{Z(s)}=\prod_{i=1}^m (g_v^{\beta
v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta y_i(s)})^{c_i}\)</span>
并添加到证明 <span class="math inline">\(\pi_F\)</span> 中</li>
</ul></li>
<li>验证
<ul>
<li>……</li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算：<span
class="math display">\[e(g_v^{V&#39;},g)=e(g_v^V,g^{\alpha_v}),e(g_w^{W&#39;},g)=e(g_w^W,g^{\alpha_w}),e(g_y^{Y&#39;},g)=e(g_y^Y,g^{\alpha_y})\]</span></li>
<li>检查多项式系数，即证明者是否使用了正确的系数来计算 <span
class="math inline">\(F(u)\)</span>，亦即 <span
class="math inline">\(V\cdot W-Y\)</span> 和 <span
class="math inline">\(t\cdot h\)</span> 的关系，<span
class="math display">\[e(g_v^V,g_w^W)=e(g_y^{t},g^h)\cdot e(g_y^Y,g)
\Rightarrow e(g,g)^{r_vr_w VW}=e(g,g)^{r_vr_wth+r_vr_wy}\]</span></li>
<li>检查操作多项式的一致性：<span class="math display">\[e(g_v^V\cdot
g_w^W\cdot g_y^Y,g^{\beta \gamma}) = e(g^Z,g^{\gamma})\]</span></li>
</ul></li>
</ul>
<p>那么到这一节为止，我们可以构造协议 8 （协议 6 + 协议 7c）如下</p>
<ul>
<li><p>设置（Settup）</p>
<ul>
<li><p>选取生成元 <span class="math inline">\(g\)</span> 和双线性映射
<span class="math inline">\(e\)</span></p></li>
<li><p>选取随机数 <span class="math inline">\(s,
\alpha_v,\alpha_w,\alpha_y,r_v,r_w,\beta,\gamma\)</span></p></li>
<li><p>计算 <span class="math inline">\(r_y=r_v\cdot r_w\)</span>
和操作多项式生成元（operand generator）<span
class="math inline">\(g_v=g^{r_v},g_w=g^{r_w},g_y=g^{r_y}\)</span><br />
</p></li>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>证明密钥：<span
class="math inline">\((\{g^{s^i}\}_{i\in[d]},\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)},g_v^{\alpha_v v_i(s)},g_w^{\alpha_w w_i(s)},g_y^{\alpha_y
y_i(s)},g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)}\}_{i\in[m]})\)</span></p></li>
<li><p>验证密钥：<span
class="math inline">\((g^1,g^{\alpha_v},g^{\alpha_w},g^{\alpha_y},g_y^{t},g^{\beta
\gamma},g^\gamma)\)</span></p></li>
</ul></li>
<li><p>证明（Proving）</p>
<ul>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>根据输入 <span class="math inline">\(u\)</span>，计算 <span
class="math inline">\(F(u)\)</span>，以及满足 QAP 的合法赋值 <span
class="math inline">\(\{c_i\}_{i\in[m]}\)</span></p></li>
<li><p>计算多项式 <span class="math display">\[V(x)=\sum_{i=1}^mc_i\cdot
v_i(x),W(x)=\sum_{i=1}^mc_i\cdot w_i(x),Y(x)=\sum_{i=1}^mc_i\cdot
y_i(x)\]</span></p></li>
<li><p>计算多项式 <span class="math inline">\(H(x)=\frac{V(x)\cdot
W(x)-Y(x)}{t(x)}\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{s^i}\}_{i\in[d]}\)</span>
计算 <span class="math inline">\(g^{H(s)}\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^{Z(s)}=\prod_{i=1}^m
(g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)})^{c_i}\)</span></p></li>
<li><p>计算操作数多项式（operand polynomials） <span
class="math display">\[g_v^{V(s)}=\prod_{i=1}^m(g_v^{v_i(s)})^{c_i},g_w^{W(s)}=\prod_{i=1}^m(g_w^{w_i(s)})^{c_i},g_y^{Y(s)}=\prod_{i=1}^m(g_y^{y_i(s)})^{c_i}\]</span></p></li>
<li><p>计算偏移多项式 <span class="math display">\[g_v^{\alpha_v
V(s)}=\prod_{i=1}^m(g_v^{\alpha_v v_i(s)})^{c_i},g_w^{\alpha_w
W(s)}=\prod_{i=1}^m(g_w^{\alpha_w w_i(s)})^{c_i},g_y^{\alpha_y
Y(s)}=\prod_{i=1}^m(g_y^{\alpha_y y_i(s)})^{c_i}\]</span></p></li>
<li><p>生成证明 <span
class="math inline">\(\pi_F=(g_v^{V(s)},g_w^{W(s)},g_y^{Y(s)},g_v^{\alpha
V(s)},g_w^{\alpha W(s)},g_y^{\alpha Y(s)},g^{H(s)},g^{Z(s)}
)\)</span></p></li>
</ul></li>
<li><p>验证（Verification）</p>
<ul>
<li>收取到证明 <span
class="math inline">\(\pi=(g_v^{V},g_w^{W},g_y^{Y},g_v^{
V&#39;},g_w^{W&#39;},g_y^{Y&#39;},g^{H},g^Z )\)</span></li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算：<span
class="math display">\[e(g_v^{V&#39;},g)=e(g_v^V,g^{\alpha_v}),e(g_w^{W&#39;},g)=e(g_w^W,g^{\alpha_w}),e(g_y^{Y&#39;},g)=e(g_y^Y,g^{\alpha_y})\]</span></li>
<li>检查多项式系数，即证明者是否使用了正确的系数来计算 <span
class="math inline">\(F(u)\)</span>，亦即 <span
class="math inline">\(V\cdot W-Y\)</span> 和 <span
class="math inline">\(t\cdot h\)</span> 的关系，<span
class="math display">\[e(g_v^V,g_w^W)=e(g_y^{t},g^h)\cdot e(g_y^Y,g)
\Rightarrow e(g,g)^{r_vr_w VW}=e(g,g)^{r_vr_wth+r_vr_wy}\]</span></li>
<li>检查操作多项式的一致性：<span class="math display">\[e(g_v^V\cdot
g_w^W\cdot g_y^Y,g^{\beta \gamma}) = e(g^Z,g^{\gamma})\]</span></li>
</ul></li>
</ul>
<h2 id="public-inputs-and-one">Public Inputs and One</h2>
<p>协议 8 可以证明，证明者掌握了 <span class="math inline">\(F\)</span>
的相关信息，并按照正确地流程计算了结果，但无法保证证明者是使用验证者所提供的输入去计算的。因此，可以让验证者指定证明者使用一些值进行计算。</p>
<p>考虑证明者要计算的加密值 <span
class="math inline">\(g_v^{V(s)},g_w^{W(s)},g_y^{Y(s)}\)</span>，由同态加密的性质可以保证，验证者可以对加密值加上其他的加密值，例如
<span class="math inline">\(g_v^{L(s)}\cdot
g_v^{l_v(s)}=g_v^{L(s)+l_v(s)}\)</span>。当然我们也可以从中减去一些加密值。我们将
<span class="math inline">\(m\)</span> 个变量多项式分为两部分，即 QAP
中所划分的输入/输出相关部分 <span
class="math inline">\(\{1,\cdots,N\}\)</span>，以及非输入/输出相关部分
<span
class="math inline">\(\{N+1,\cdots,m\}\)</span>。让证明者只使用非输入/输出部分进行计算，验证者使用输入/输出部分进行验证。这样，我们就可以构造协议
9：</p>
<ul>
<li><p>设置（Settup）</p>
<ul>
<li><p>选取生成元 <span class="math inline">\(g\)</span> 和双线性映射
<span class="math inline">\(e\)</span></p></li>
<li><p>选取随机数 <span class="math inline">\(s,
\alpha_v,\alpha_w,\alpha_y,r_v,r_w,\beta,\gamma\)</span></p></li>
<li><p>计算 <span class="math inline">\(r_y=r_v\cdot r_w\)</span>
和操作多项式生成元（operand generator）<span
class="math inline">\(g_v=g^{r_v},g_w=g^{r_w},g_y=g^{r_y}\)</span><br />
</p></li>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，<span
class="math inline">\(F\)</span> 有 <span
class="math inline">\(N\)</span> 个输入输出变量，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>令 <span
class="math inline">\(I_{mid}=\{N+1,\cdots,m\}\)</span></p></li>
<li><p>证明密钥：<span
class="math inline">\((\{g^{s^i}\}_{i\in[d]},\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)},g_v^{\alpha_v v_i(s)},g_w^{\alpha_w w_i(s)},g_y^{\alpha_y
y_i(s)},g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)}\}_{i\in I_{mid}})\)</span></p></li>
<li><p>验证密钥：<span
class="math inline">\((g^1,g^{\alpha_v},g^{\alpha_w},g^{\alpha_y},g_y^{t},g^{\beta
\gamma},g^\gamma,\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)}\}_{i\in[0,N]})\)</span></p></li>
</ul></li>
<li><p>证明（Proving）</p>
<ul>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>根据输入 <span class="math inline">\(u\)</span>，计算 <span
class="math inline">\(F(u)\)</span>，以及满足 QAP 的合法赋值 <span
class="math inline">\(\{c_i\}_{i\in[m]}\)</span></p></li>
<li><p>计算多项式 <span class="math display">\[V(x)=\sum_{i=1}^mc_i\cdot
v_i(x),W(x)=\sum_{i=1}^mc_i\cdot w_i(x),Y(x)=\sum_{i=1}^mc_i\cdot
y_i(x)\]</span></p></li>
<li><p>计算多项式 <span class="math inline">\(H(x)=\frac{V(x)\cdot
W(x)-Y(x)}{t(x)}\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{s^i}\}_{i\in[d]}\)</span>
计算 <span class="math inline">\(g^{H(s)}\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^{Z(s)}=\prod_{i\in I_{mid}}
(g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)})^{c_i}\)</span></p></li>
<li><p>计算操作数多项式（operand polynomials） <span
class="math display">\[g_v^{V(s)}=\prod_{i\in
I_{mid}}(g_v^{v_i(s)})^{c_i},g_w^{W(s)}=\prod_{i\in
I_{mid}}(g_w^{w_i(s)})^{c_i},g_y^{Y(s)}=\prod_{i\in
I_{mid}}(g_y^{y_i(s)})^{c_i}\]</span></p></li>
<li><p>计算偏移多项式 <span class="math display">\[g_v^{\alpha_v
V(s)}=\prod_{i\in I_{mid}}(g_v^{\alpha_v v_i(s)})^{c_i},g_w^{\alpha_w
W(s)}=\prod_{i\in I_{mid}}(g_w^{\alpha_w w_i(s)})^{c_i},g_y^{\alpha_y
Y(s)}=\prod_{i\in I_{mid}}(g_y^{\alpha_y
y_i(s)})^{c_i}\]</span></p></li>
<li><p>生成证明 <span
class="math inline">\(\pi_F=(g_v^{V(s)},g_w^{W(s)},g_y^{Y(s)},g_v^{\alpha
V(s)},g_w^{\alpha W(s)},g_y^{\alpha Y(s)},g^{H(s)},g^{Z(s)}
)\)</span></p></li>
</ul></li>
<li><p>验证（Verification）</p>
<ul>
<li>收取到证明 <span
class="math inline">\(\pi=(g_v^{V_{mid}},g_w^{W_{mid}},g_y^{Y_{mid}},g_v^{
V_{mid}&#39;},g_w^{W_{mid}&#39;},g_y^{Y_{mid}&#39;},g^{H},g^Z
)\)</span></li>
<li>计算 <span class="math inline">\(g_v^{V}=g_v^{v_0(s)}\cdot
\prod_{i\in [N]} (g_v^{v_{i}(s)})^{c_i} \cdot
g_v^{V_{mid}}\)</span>，$g_w<sup>{W}=g_w</sup>{w_0(s)}<em>{i}
(g_w<sup>{w_{i}(s)})</sup>{c_i} g_w^{W</em>{mid}} <span
class="math inline">\(，\)</span>g_y<sup>{Y}=g_y</sup>{y_0(s)}<em>{i}
(g_y<sup>{y_{i}(s)})</sup>{c_i} g_y^{Y</em>{mid}} $</li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算：<span
class="math display">\[e(g_v^{V_{mid}&#39;},g)=e(g_v^{V_{mid}},g^{\alpha_v}),e(g_w^{W&#39;_{mid}},g)=e(g_w^{W_{mid}},g^{\alpha_w}),e(g_y^{Y&#39;_{mid}},g)=e(g_y^{Y_{mid}},g^{\alpha_y})\]</span></li>
<li>检查多项式系数，即证明者是否使用了正确的系数来计算 <span
class="math inline">\(F(u)\)</span>，亦即 <span
class="math inline">\(V\cdot W-Y\)</span> 和 <span
class="math inline">\(t\cdot h\)</span> 的关系，<span
class="math display">\[e(g_v^V,g_w^W)=e(g_y^{t},g^h)\cdot
e(g_y^Y,g)\]</span></li>
<li>检查操作多项式的一致性：<span
class="math display">\[e(g_v^{V_{mid}}\cdot g_w^{W_{mid}}\cdot
g_y^{Y_{mid}},g^{\beta \gamma}) = e(g^Z,g^{\gamma})\]</span></li>
</ul></li>
</ul>
<p>注：<span class="math inline">\({v_0(x)},{w_0(x)},{y_0(x)}\)</span>
是在对某些函数做转换时，一些常数多项式的约束条件无法用 QAP
来表示而引入的，其值在转换的过程中会自然的计算出，而不需要另外的赋值。</p>
<p>当协议 9 中的 <span
class="math inline">\(\alpha\)</span>-偏移，使用的是同一个 <span
class="math inline">\(\alpha\)</span> 时，即 <span
class="math inline">\(\alpha=\alpha_v=\alpha_w=\alpha_y\)</span>，此时协议
9 就是 [Par+13] 所构造的 Pinocchio 协议。</p>
<h2 id="zero-knowledge">Zero Knowledge</h2>
<p>接下来，考虑将零知识的性质添加到协议上，即可构成一个完整的 zk-SNARK
协议。</p>
<p>在对多项式整除性进行检查时，我们可以使用一个 <span
class="math inline">\(\delta\)</span>-偏移，来隐藏原本的多项式，并使偏移后的多项式依然满足整除性要求，即：</p>
<p><span class="math display">\[\begin{aligned}\delta
P(s)&amp;=t(s)\cdot \delta H(s)\\
\delta(V(s)\cdot W(s)-Y(s))&amp;=\delta t(s)H(s)\\
\Rightarrow \delta V(s)\cdot \delta W(s)-\delta^2 Y(s)&amp;=t(s) \cdot
\delta^2 H(s)\\
e(g,g)^{\delta^2 V(s)W(s)}&amp;=e(g,g)^{\delta^2(t(s)H(s)+Y(s))}
\end{aligned}\]</span></p>
<p>和前述章节一样，使用相同的的随机数进偏移，也会造成一些信息的泄露。所以可以对不同的多项式进行不同的偏移，即</p>
<p><span class="math display">\[\delta_v V(s)\cdot \delta_w W(s) -
\delta_v\delta_w Y(s)=t(s)\cdot (\delta_v\delta_w H(s))\]</span></p>
<p>偏移后的整除性依然满足。但如果证明者这样添加了偏移，验证者的输入也需要进行对应的偏移，那么双方就需要有交互的过程。这不符合非交互性的定义。</p>
<p>在这里，我们考虑使用加法来做随机偏移：</p>
<p><span class="math display">\[(V(s)+\delta_v t(s))\cdot (W(s)+\delta_w
t(s))-(Y(s)+\delta_y t(s))=t(s)\cdot (\Delta+h(s))\]</span></p>
<p>在这里，为了满足整除性，取 <span
class="math inline">\(\Delta=\delta_w V(s)+\delta_v W(s)+\delta_v
\delta_w t(s)- \delta_y\)</span>。我们仍然可以计算其同态值 <span
class="math inline">\(g^{\Delta}=(g^{V(s)})^{\delta_w}\cdot
(g^{W(s)})^{\delta_v}\cdot (g^{t(s)})^{\delta_v \delta_w} g^{-\delta_y},
g^{V(s)+\delta_v t(s)}=g^{V(s)}\cdot
(g^{t(s)})^{\delta_v}\)</span>，以及同样地计算 <span
class="math inline">\(g^{W(s)+\delta_w t(s)},g^{Y(s)+\delta_y
t(s)}\)</span>。那么整除性的检验就变成了 <span
class="math display">\[V\cdot W-Y+t(s)(\delta_wV+\delta_vW+\delta_v
\delta_w t(s)-\delta_y)=t(s)H+t(s)(\delta_wV+\delta_vW+\delta_v \delta_w
t(s)-\delta_y)\]</span></p>
<p>为了使得多项式限制检验和多项式一致性检验同样使用了 <span
class="math inline">\(\delta\)</span>-偏移。我们需要在证明密钥中添加如下值：<span
class="math display">\[g_v^{t(s)},g_w^{t(s)},g_y^{t(s)},g_v^{\alpha_v
t(s)},g_w^{\alpha_w t(s)},g_y^{\alpha_y t(s)},,g_v^{\beta
t(s)},g_w^{\beta t(s)},g_y^{\beta t(s)}\]</span></p>
<p>这样我们就可以构造一个零知识的 Pinocchio 协议，亦即一个完整的
zk-SNARK 协议。</p>
<ul>
<li><p>设置（Settup）</p>
<ul>
<li><p>选取生成元 <span class="math inline">\(g\)</span> 和双线性映射
<span class="math inline">\(e\)</span></p></li>
<li><p>选取随机数 <span class="math inline">\(s,
\alpha_v,\alpha_w,\alpha_y,r_v,r_w,\beta,\gamma\)</span></p></li>
<li><p>计算 <span class="math inline">\(r_y=r_v\cdot r_w\)</span>
和操作多项式生成元（operand generator）<span
class="math inline">\(g_v=g^{r_v},g_w=g^{r_w},g_y=g^{r_y}\)</span><br />
</p></li>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，<span
class="math inline">\(F\)</span> 有 <span
class="math inline">\(N\)</span> 个输入输出变量，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>令 <span
class="math inline">\(I_{mid}=\{N+1,\cdots,m\}\)</span></p></li>
<li><p>证明密钥：<span
class="math inline">\((\{g^{s^i}\}_{i\in[d]},\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)},g_v^{\alpha_v v_i(s)},g_w^{\alpha_w w_i(s)},g_y^{\alpha_y
y_i(s)},g_v^{\beta v_i(s)}\cdot g_w^{\beta w_i(s)}\cdot g_y^{\beta
y_i(s)}\}_{i\in I_{mid}},g_v^{t(s)},g_w^{t(s)},g_y^{t(s)},g_v^{\alpha_v
t(s)},g_w^{\alpha_w t(s)},g_y^{\alpha_y t(s)},,g_v^{\beta
t(s)},g_w^{\beta t(s)},g_y^{\beta t(s)})\)</span></p></li>
<li><p>验证密钥：<span
class="math inline">\((g^1,g^{\alpha_v},g^{\alpha_w},g^{\alpha_y},g_y^{t},g^{\beta
\gamma},g^\gamma,\{g_v^{v_i(s)},g_w^{w_i(s)},g_y^{
y_i(s)}\}_{i\in[0,N]})\)</span></p></li>
</ul></li>
<li><p>证明（Proving）</p>
<ul>
<li><p>根据公布的函数 <span class="math inline">\(F\)</span>，计算其 QAP
形式，包括一个目标多项式 <span class="math inline">\(t(x)\)</span>
和三个多项式集合 <span
class="math inline">\(\mathcal{V}=\{v_i(x)\},\mathcal{W}=w_i(x)\},\mathcal{Y}=\{y_i(x)\},i\in
[m]\)</span>，其大小（size）为 <span
class="math inline">\(m\)</span>，次数为 <span
class="math inline">\(d\)</span></p></li>
<li><p>根据输入 <span class="math inline">\(u\)</span>，计算 <span
class="math inline">\(F(u)\)</span>，以及满足 QAP 的合法赋值 <span
class="math inline">\(\{c_i\}_{i\in[m]}\)</span></p></li>
<li><p>计算多项式 <span class="math display">\[V(x)=\sum_{i=1}^mc_i\cdot
v_i(x),W(x)=\sum_{i=1}^mc_i\cdot w_i(x),Y(x)=\sum_{i=1}^mc_i\cdot
y_i(x)\]</span></p></li>
<li><p>选取随机数 <span
class="math inline">\(\delta_v,\delta_w,\delta_y\)</span></p></li>
<li><p>计算多项式 <span class="math inline">\(H(x)=\frac{V(x)\cdot
W(x)-Y(x)}{t(x)}+\delta_wV(x)+\delta_vW(x)+\delta_v \delta_w
t(x)-\delta_y\)</span></p></li>
<li><p>使用 <span class="math inline">\(\{g^{s^i}\}_{i\in[d]}\)</span>
计算 <span class="math inline">\(g^{H(s)}\)</span></p></li>
<li><p>计算 <span class="math inline">\(g^{Z(s)}=(g_v^{\beta
t(s)})^{\delta_v}(g_w^{\beta t(s)})^{\delta_w}(g_y^{\beta
t(s)})^{\delta_y}\cdot \prod_{i\in I_{mid}} (g_v^{\beta v_i(s)}\cdot
g_w^{\beta w_i(s)}\cdot g_y^{\beta y_i(s)})^{c_i}\)</span></p></li>
<li><p>计算操作数多项式（operand polynomials） <span
class="math display">\[g_v^{V_{mid}(s)}=(g_v^{\beta
t(s)})^{\delta_v}\cdot \prod_{i\in I_{mid}}(g_v^{v_i(s)})^{c_i},
  g_w^{W_{mid}(s)}=(g_w^{\beta t(s)})^{\delta_w}\cdot \prod_{i\in
I_{mid}}(g_w^{w_i(s)})^{c_i},
  g_y^{Y_{mid}(s)}=(g_y^{\beta t(s)})^{\delta_y}\cdot \prod_{i\in
I_{mid}}(g_y^{y_i(s)})^{c_i}\]</span></p></li>
<li><p>计算偏移多项式 <span
class="math display">\[g_v^{V_{mid}&#39;(s)}=(g_v^{\alpha_v
t(s)})^{\delta_v}\cdot \prod_{i\in I_{mid}}(g_v^{\alpha_v
v_i(s)})^{c_i},
  g_w^{W_{mid}&#39;(s)}=(g_w^{\alpha_w t(s)})^{\delta_w}\cdot
\prod_{i\in I_{mid}}(g_w^{\alpha_w w_i(s)})^{c_i},
  g_y^{Y_{mid}&#39;(s)}=(g_y^{\alpha_y t(s)})^{\delta_y}\cdot
\prod_{i\in I_{mid}}(g_y^{\alpha_y y_i(s)})^{c_i}\]</span></p></li>
<li><p>生成证明 <span
class="math inline">\(\pi_F=(g_v^{V_{mid}(s)},g_w^{W_{mid}(s)},g_y^{Y_{mid}(s)},g_v^{V&#39;_{mid}(s)},g_w^{W&#39;_{mid}(s)},g_y^{Y&#39;_{mid}(s)},g^{H(s)},g^{Z(s)})\)</span></p></li>
</ul></li>
<li><p>验证（Verification）</p>
<ul>
<li>收取到证明 <span
class="math inline">\(\pi=(g_v^{V_{mid}},g_w^{W_{mid}},g_y^{Y_{mid}},g_v^{
V_{mid}&#39;},g_w^{W_{mid}&#39;},g_y^{Y_{mid}&#39;},g^{H},g^Z
)\)</span></li>
<li>计算 <span class="math inline">\(g_v^{V}=g_v^{v_0(s)}\cdot
\prod_{i\in [N]} (g_v^{v_{i}(s)})^{c_i} \cdot
g_v^{V_{mid}}\)</span>，$g_w<sup>{W}=g_w</sup>{w_0(s)}<em>{i}
(g_w<sup>{w_{i}(s)})</sup>{c_i} g_w^{W</em>{mid}} <span
class="math inline">\(，\)</span>g_y<sup>{Y}=g_y</sup>{y_0(s)}<em>{i}
(g_y<sup>{y_{i}(s)})</sup>{c_i} g_y^{Y</em>{mid}} $</li>
<li>检查多项式限制（polynomial
restriction），即是否使用了给定的多项式计算：<span
class="math display">\[e(g_v^{V_{mid}&#39;},g)=e(g_v^{V_{mid}},g^{\alpha_v}),e(g_w^{W&#39;_{mid}},g)=e(g_w^{W_{mid}},g^{\alpha_w}),e(g_y^{Y&#39;_{mid}},g)=e(g_y^{Y_{mid}},g^{\alpha_y})\]</span></li>
<li>检查多项式系数，即证明者是否使用了正确的系数来计算 <span
class="math inline">\(F(u)\)</span>，亦即 <span
class="math inline">\(V\cdot W-Y\)</span> 和 <span
class="math inline">\(t\cdot h\)</span> 的关系，<span
class="math display">\[e(g_v^V,g_w^W)=e(g_y^{t},g^h)\cdot
e(g_y^Y,g)\]</span></li>
<li>检查操作多项式的一致性：<span
class="math display">\[e(g_v^{V_{mid}}\cdot g_w^{W_{mid}}\cdot
g_y^{Y_{mid}},g^{\beta \gamma}) = e(g^Z,g^{\gamma})\]</span></li>
</ul></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>最终我们所构造的协议有如下的性质：</p>
<ul>
<li>简洁性：所需证明 <span class="math inline">\(\pi\)</span>
的大小是固定的，且只有 8 个元素</li>
<li>非交互性：一个证明 <span class="math inline">\(\pi\)</span>
可以被任意方所验证，而不需要和证明者进行交互</li>
<li>正确性：一个陈述可以以极高的概率证明成功</li>
<li>零知识性：从证明中提取出有效的信息是不可行（infeasible）的</li>
</ul>
<h2 id="reference">Reference</h2>
<ol type="1">
<li>http://eprint.iacr.org/2013/279</li>
<li>https://arxiv.org/pdf/1906.07221</li>
<li>https://drive.google.com/file/d/0B-WxC9ydKhlRZG92dnJ0RmdWRkZKUXR5Q3FTd0pZMl9Tdnln/view</li>
<li>https://www.zeroknowledgeblog.com/index.php/the-pinocchio-protocol</li>
<li>http://people.seas.harvard.edu/~salil/research/SZKargs-focs.pdf</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/QAP%E8%AF%A6%E8%A7%A3/" rel="prev" title="QAP 详解">
                  <i class="fa fa-chevron-left"></i> QAP 详解
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
